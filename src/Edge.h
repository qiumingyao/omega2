#ifndef EDGE_H
#define EDGE_H

//============================================================================
// Name        : Edge.h
// Author      : Tae-Hyuk (Ted) Ahn, JJ Crosskey
// Version     : v1.2
// Copyright   : 2015 Oak Ridge National Lab (ORNL). All rights reserved.
// Description : Edge header file
//============================================================================


#include "Config.h"
#include "Read.h"

class Read;

extern TLogLevel loglevel;                      /* verbosity level of logging */
typedef vector<pair<UINT32, UINT32> > t_vpair;
class Edge{
	private:
		/* ====================  DATA MEMBERS  ======================================= */
		Read *m_source;
		Read *m_destination;

		/* 0 = u<-----------<v		reverse of u to reverse of v
		 * 1 = u<----------->v		reverse of u to forward of v
		 * 2 = u>-----------<v		forward of u to reverse of v
		 * 3 = u>----------->v		forward of u to forward of v
		 */
		UINT8 m_orient;

		/* overlap offset in the following example is 6
		 *   012345678901234567890123456789
		 * u ACTTACGGGATTATACCATCGAGA
		 * v       GGGATTATACCATCGAGATTCAAT
		 */
		UINT32 m_overlapOffset;

		/*  flag of edge that has these bits:
		 *  0x1: not dead end
		 *  0x2: loop
		 */
		INT8 m_flag;	

		// String generated by the edge
		std::string m_string;

		vector< vector<UINT64> > m_mismatch_basecount;

		// mismatch positions in the edge (index, position) where index is 
		// from the index of the listOfReads (if simple edge, then 0)
		t_vpair * m_mismatches;	

		// List of ordered reads in the current edge. NOT including u and v.
		vector<Read* > * m_listOfReads;

		/*  List of overlap offsets of the ordered reads in the current edge.
		 *  The offset of the destination read is calculated as 
		 *  m_overlapOffset - sum(m_listOfOverlapOffsets[i]) or it can retrieved from the reverse edge
		 */
		vector<UINT32> * m_listOfOverlapOffsets; 	
		
		/*  List of orientations of the ordered reads in the current edge.
		 *  orientation is 0 or 1. 
		 *  0 means read's reverse complement read.getStringReverse(). 
		 *  1 means read's forward string.
		 */
		vector<UINT8> * m_listOfOrientations;

		/*  This points to the reverse edge in the overlap graph.
		 *  Each edge (u,v) is present twice in the graph.
		 *  Edge (u,v) is present in the list of edges of node u
		 *  Edge (v,u) is present in the list of edges of node v.
		 *  Edge (u,v) and (v,u) are called twin edges and are reverse edges of each another.
		 *  the reverseEdge always have the same flow as the forward Edge
		 *  the listOfReads of the reverse edge is the same reads in reverse order as the forward edge
		 *  the m_listOfOrientations of the reverse edge is reverse complement
		 */
		Edge *m_reverseEdge;						
		
		INT64 m_edgeID;                   // Used in read threading, twin edges have opposite edge IDs

		UINT64 m_contigEdgeID;            // Used for printing contigs

		float m_coverageDepth;           // Average depth of coverage.
		
		float m_SD;                      // Standard deviation of the base-by-base coverage depth

		/* ====================  METHODS      ======================================= */
		friend Edge*  merge_forward_edges(const Edge & edge1, const Edge & edge2);

		void copyEdge(const Edge &edge);

		void clearEdge();

		t_vpair * getReverseMismatches() const;

		vector<UINT32> * getReverseListOfOverlapOffsets() const;

		vector<Read* > * getReverseListOfReads();

		vector<UINT8> * getReverseListOfOrient();


	public:
		/* ====================  DATA MEMBERS  ======================================= */
		UINT32 m_flow;                    // Store the flow in the current edge.
		
		/* ====================  LIFECYCLE     ======================================= */
		// Default constructor.
		Edge(void);								

		// constructor for a non-empty edge
		Edge(Read *source, Read *destination, UINT8 orient, UINT32 overlapOffset, t_vpair *mismatches);

		Edge(Read *from, Read *to, UINT8 orient, UINT32 overlapOffset, t_vpair *mismatchesInput,
				vector<Read* > *listReads, vector<UINT32> *listOverlapOffsets, 
				vector<UINT8> * listOrientations);  

		Edge(const Edge &edge);
		// Destructor.
		~Edge();								

		/* ====================  OPERATORS     ======================================= */
		Edge& operator=(const Edge &edge);

		friend ostream& operator<< (ostream &out, const Edge &edge);

//		friend ostream& operator<< (ostream &out, const Edge *edge);

//		friend Edge operator+ (const Edge & edge1, const Edge & edge2);

		friend Edge* Add( const Edge *edge1, const Edge *edge2);

		/* ====================  MUTATORS      ======================================= */
		// Set the pointer to the reverse edge, only if reverse edge is nullptr
		void setReverseEdge(Edge * edge);

		void setContigEdgeID(const UINT64 & n) {m_contigEdgeID = n;}

		void setEdgeID(const INT64 & n) {m_edgeID = n; m_reverseEdge->m_edgeID = (-n);}

		void updateReadsLocations(EdgeOP operation);

		void markNotDeadEnd() {m_flag |= 1; m_reverseEdge->m_flag |= 1;}

		void markLoop() {m_flag |= (1 << 1);}

		void loadReadString(const std::string read_str, int index);

		void make_reverseEdge();

		/* ====================  ACCESSORS     ======================================= */
		// Get the read object of the source node.
		Read * getSourceRead() const {return m_source;}	

		// Check if an edge is marked as not dead end
		bool isNotDeadEnd() const { return (m_flag & 1);}

		// Check if an edge is a loop
		bool isLoop() const {return (m_flag >> 1) & 1;}

		// Get the read object of the destination node.
		Read * getDestinationRead() const {return m_destination; }	

		// Return the orientation of the edge.
		UINT8 getOrientation() const {return m_orient;}	

		// Return the overlap offset.
		UINT32 getOverlapOffset() const {return m_overlapOffset;}	

		// Get mismatch positions
		t_vpair * getMismatches() const {return m_mismatches;}

		// Get the ordered list of reads in the current edge.
		vector<Read* > * getListOfReads() const {return m_listOfReads;}		

		// Get the list of ordered offset.
		vector<UINT32> * getListOfOverlapOffsets() const {return m_listOfOverlapOffsets;} 

		// Get the ordered orientation of the reads. 1 means forward. 0 means reverse.
		vector<UINT8> * getListOfOrientations() const {return m_listOfOrientations;}	

		// Return the pointer to the reverse edge.
		Edge * getReverseEdge() const {return m_reverseEdge;}	

		UINT64 getContigEdgeID() const {return m_contigEdgeID;}

		INT64 getEdgeID() const {return m_edgeID;}

		UINT32 getOverlapLen() const;

		UINT32 getFirstOverlapOffset() const 
		{
			if (!m_listOfOverlapOffsets || m_listOfOverlapOffsets->empty())
				return m_overlapOffset;
			else
				return (m_listOfOverlapOffsets->at(0));
		}

		UINT64 getEdgeLength() const {return m_overlapOffset + m_destination->getReadLength();}

		UINT32 getLastOverlapOffset() const;

		std::string getEdgeString() const {return m_string;}

		bool isSmallerEdge() const 
		{
			if(m_source->getReadID() < m_destination->getReadID())
				return true;
			else if (m_source->getReadID() > m_destination->getReadID())
				return false;
			else if(this < m_reverseEdge)
				return true;
			else
				return false;
		}

		// Get base by base coverage
		void getBaseByBaseCoverage();

		float getCovDepth() const {return m_coverageDepth;}

		float getCovSD() const {return m_SD;}

		INT8 getFlag() const {return m_flag;}
		/* ====================  OPERATIONS     ======================================= */
		// Break edge at a specific link if the edge is composite, otherwise return empty vector
		// Just do the forward edge
		vector<Edge*> breakForwardEdge(const UINT32 &link) const;

		// Break edge at specific link, but also do the twin edge accordingly
		vector<Edge*> breakEdge(const UINT32 &link) const;

};

bool is_mergeable(const Edge *edge1, const Edge *edge2);

UINT8 mergedEdgeOrientation(const UINT8 &orient1, const UINT8 &orient2);

UINT8 get_twin_orient(const UINT8 &orient);

void mergeList(const Edge *edge1, const Edge *edge2, 
		vector<Read* > *listReads, vector<UINT32> *listOverlapOffsets, vector<UINT8> *listOrientations, 
		t_vpair *mismatchesForward);

Edge * mergeEdges(const vector<Edge *> & list_edges);

template <typename T>
float get_mean(const vector<T> &numbers);

template <typename T>
float get_sd(const vector<T> &numbers);
#endif /* EDGE_H */
